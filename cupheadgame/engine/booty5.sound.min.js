//Based on WebAudioPlayer plugin for DS by AndrewDev (unreleased) and Sound from Booty5
//Created by: AndrewDev for Booty5.2.0
//You can use this separatedly from the game engine in yout webapp, credits are appreciated
try {
	b5
}catch(e) {
	b5 = {
		app: {
			use_web_audio: true,
			audio_config: {
				sampleRate: 44100
			}}}}
'use_strict',
b5.Sound = function(e, t, o, a, r, n) {
	this.parent = null,
	this.buffer = null,
	this.context = b5.Sound.context,
	this.name = e,
	this.type = "sound",
	this.location = t,
	this.location2 = null,
	this.loop=!1,
	this.loop_start = 0,
	this.loop_end = 0,
	this.duration = 0,
	this.sample_rate = 0,
	this.samples = 0,
	this.start_pos = 0,
	this.reuse = void 0 !== a && a,
	this.preload = void 0 !== o && o,
	this.load_retry = 0,
	this.loaded=!1,
	this.loading=!1,
	this.auto_play=!1,
	this.gain = 1,
	this.output_gain = 1,
	this.stereo_pan = 0,
	this.playback_speed = 1,
	this.detune = 0,
	this.keep_pitch = !1,
	this.destr = r || !1,
	this.id = 0,
	//Effects
	this.equalizer = !1,
	this.limiter = !1,
	this.reverb = !1,
	this.analyser = null,
	this.output = !0,
	this.stream = !1,
	!n && (n = {});
	//Set effects
	for (var r in n) r != "analyser" && (this[r] = n[r]);
	n.analyser && (this.analyser = this.context.createAnalyser(), this.analyser.type = "frequencies", this.analyser.buffer = null),
	this._setupAudio = function() {
		this.audio = this.context.createMediaElementSource(new Audio());
	},
	this.stream && this._setupAudio();
	this.eq = {
		type: "allpass",
		freq: 0,
		gain: 0,
		Q: 1,
		detune: 0
	},
	this.compressor = {
		threshold: -24,
		knee: 30,
		ratio: 12,
		attack: 0.003,
		release: 0.25
	},
	this.player = {
		sources: [],
		nodes: [],
		data: [],
		count: 0
	},
	this.preload && this.load(!1),
	this.internal = {
		_createSource: function(e) {
			var b;
			//Create buffer source for playback and add it to player sources
			if (!e.stream) {
				b = e.context.createBufferSource();
				b.buffer = e.buffer,
				b.parent = e,
				b.playbackRate.value = e.playback_speed,
				b.detune.value = e.detune,
				b.loop = e.loop,
				b.loopStart = e.loop_start,
				b.loopEnd = e.loop_end,
				b.source_index = e.player.sources.length,
				b.ended = !1;
				b.onended = function(n) {
					var e = this.parent,
					t = e.player ? e.player.count-1: 0,
					o = e.player;

					this.ended = !0;
					try {
						n === true && this.stop();
					}catch(e) {}
					if (o) {
						o.count = o.sources.length-1;
						t = b.source_index;
						//Substract one from list
						for (var i = 0, a = o.sources; i < a.length; i++) {
							a[i] && a[i].source_index > 0 && a[i].source_index--;
						}


						e.internal._disconnect(e),
						o.sources[t] = null,
						o.sources.splice(t, 1),
						o.nodes[t] = null,
						o.nodes.splice(t, 1),
						o.data.splice(t, 1),
						this.onended = null;
						e.onComplete && e.onComplete(b.source_index, o.count);
						e.destr && o.count == 0 && e.destroy();
					}
				};
			} else {
				b = e.audio,
				// e.context.createMediaElementSource(e.audio);
				b.parent = e,
				b.mediaElement.playbackRate = e.playback_speed,
				b.mediaElement.loop = e.loop,
				b.source_index = e.player.sources.length,
				b.mediaElement.preservesPitch = e.keep_pitch,
				b.mediaElement.parent = e,
				b.ended = !1,
				b.mediaElement.onended = function(n) {
					var e = this.parent,
					t = e.player.count-1,
					o = e.player;
					this.ended = !0,
					n && this.mediaElement ? this.mediaElement.pause(): this.pause();
					//Substract one from list
					for (var i = 0, a = o.sources; i < a.length; i++) {
						this.source_index > 0 && this.source_index--;
					}
					e.internal._disconnect(e),
					o.sources[t] = null,
					o.sources.splice(t, 1),
					o.nodes[t] = null,
					o.nodes.splice(t, 1),
					o.count > 0 && o.count--,
					o.data.splice(t, 1),
					this.onended = null;
					e.onComplete && e.onComplete(b.source_index);
					e.destr && o.count == 0 && e.destroy();
				};
				b.onended = function(m) {
					this.mediaElement.onended(m)
				};
			}
			e.player.sources.push(b);
			//Add data to player
			e.player.data.push({
				playing: !1,
				wasplaying: !1,
				paused: !1,
				playbackRate: e.playback_speed,
				playbackRateMult: 1,
				output_connected: e.output,
				bufferenabled: !e.stream
			});
		},
		_createNodes: function(e, t) {
			//Create a gain and a pan node as default for basic audio playback
			var r = b5.Sound.context,
			o = r.createGain();
			o.gain.value = e.gain,
			o.parent = e;

			var a = r.createStereoPanner();
			a.pan.value = e.stereo_pan,
			a.parent = e;

			//Add to node list to connect
			var n = e.player.nodes,
			p = e.player.count;
			null == n[p] && (n[p] = []);
			n[p].push(o);
			n[p].push(a);

			//Add extra nodes (effects)
			if (e.equalizer) {
				var i = r.createBiquadFilter(),
				s = e.eq;
				i.type = s.type,
				i.frequency.value = s.freq,
				i.gain.value = s.gain,
				i.Q.value = s.Q,
				n[p].push(i);
			} else n[p].push(r.createGain());

			if (e.limiter) {
				var b = r.createDynamicsCompressor(),
				c = e.compressor;
				b.threshold.value = c.threshold,
				b.ratio.value = c.ratio,
				b.knee.value = c.knee,
				b.attack.value = c.attack,
				b.release.value = c.release,
				n[p].push(b);
			} else n[p].push(r.createGain());

			if (e.reverb) {
				var c = r.createConvolver(),
				b = r.createGain();
				c.buffer = b5.Sound.IR_buffer;
				n[p][n.length-1].connect(c);
				c.connect(b);
				b.gain.value = 0;
				b.connect(r.destination);
				c.gainNode = b;
				n[p].REVERB_NODE = c;
			}

			//Secondary gain (for the whole composition)
			var d = r.createGain();
			d.gain.value = e.output_gain;
			d.parent = e;

			//Add output gain
			n[p].push(d);
		},
		_connect: function(e, a) {
			//Nodes for each player
			var t = e.player.nodes[a || e.player.count] || [],
			o = e.player.sources[a || e.player.count];
			for (var i = 0, r=!1, s = 1; i <= t.length-1; i++) {
				t[i] != null && o ? (
					i === 0 && o.connect(t[i]),
					t[i-s] != null && t[i-s].connect(t[i]),
					i === t.length-1 && e.output && (r=!0, t[i].connect(e.context.destination))
				): s++;
				if (r)break;
			}
		},
		_disconnect: function(e, n) {
			//Nodes for each player
			var a = +n ? +n: (e.player.count-1),
			t = e.player.nodes[a] || [],
			o = e.player.sources[a];
			t.REVERB_NODE && t.REVERB_NODE.disconnect(e.context.destination);
			for (var i = 0, r=!1, s = 1; i <= t.length-1; i++) {
				if (t[i] != null) {
					if (t[i-s] != null) try {
						t[i-s].disconnect(t[i])}catch(e) {}
					i === t.length-1 && t[i].output_connected && (r=!0, t[i].disconnect(e.context.destination), e.analyser && t[i].disconnect(e.analyser), t[i] = null)
				} else s++;
				if (r)break;
			}
		},
		_reconnect: function(e, n) {
			+n && (this._disconnect(e, n), this._connect(e, n));
		}
	};
},
//Create an AudioContext
b5.Sound.context = null;
b5.Sound.offlineContext = null;
b5.Sound.IR_buffer = null; //Reverb
b5.Sound.init = function(e, t) {
	null === this.context ? (
		this.context = new AudioContext(t),
		this.offlineContext = new OfflineAudioContext(2, 44100, 44100)
	): this.context.resume();
	this._timer = setTimeout(function() {
		e && e(b5.Sound.context.state)}, 2000);
	this.context.onstatechange = function() {
		clearTimeout(b5.Sound._timer),
		e && e(b5.Sound.context.state),
		this.onstatechange = null;
	};
	this.IR_buffer = this.generateImpulseResponse( (t && t.reverbGenerator) || b5.Sound.reverbGenerator, (t && t.reverbTime) || 1);
},
b5.Sound.decodeAudioData = function(e, t, o) {
	return b5.Sound.offlineContext.decodeAudioData(e, t, o);
},
b5.Sound.prototype.load = function(e) {
	var _ = this;
	_.loading = !0;
	if (!_.stream) {
		var a = new XMLHttpRequest();
		a.open('GET', e?this.location2: this.location, !0);
		//Read as arraybuffer
		a.responseType = 'arraybuffer';
		a.onload = function() {
			//Decode audio data
			b5.Sound.decodeAudioData(this.response).then(function(t) {
				//Save buffer
				_.buffer = t,
				_.duration = t.duration,
				_.sample_rate = t.sampleRate,
				_.samples = t.length,
				!_.loop_end && (_.loop_end = t.duration),
				b5.app.onResourceLoaded(_, !1),
				_.auto_play && _.play(),
				_.onload && _.onload(_, !0);
			}).catch(function(m) {
				_.load_retry++, 3 < _.load_retry?(b5.app.onResourceLoaded(_, !0), _.onload !== void 0 && _.onload(_, !1)): _.load(!0);
			});
		},
		a.onerror = ()=> {
			_.context && a.onload()}
		a.send();
	} else {
		var n = _.audio.mediaElement;
		n.onloadeddata = function() {
			_.duration = this.duration,
			b5.app.onResourceLoaded(_, !1),
			_.auto_play && _.play(),
			_.onload && _.onload(_, !0);
		},
		n.onerror = function() {
			_.load_retry++,
			3 < _.load_retry?(b5.app.onResourceLoaded(_, !0), _.onload !== void 0 && _.onload(_, !1)): _.load(!0);
		},
		n.src = e?this.location2: this.location;
	}
},
b5.Sound.prototype.destroy = function() {
	this.onDestroy && this.onDestroy(this);
	this.isPlaying() && (this.destr = !1, this.stop());
	null !== this.parent && this.parent.removeResource(this, 'sound');
	//Delete object data to save memory (via GC)
	for (var i in this) this[i] = null;
},
//If you have two separared players that use the same audio file,
//You can just copy the buffer data from that player. (Needs to be loaded first, use this when loaded)
b5.Sound.prototype.copyBufferFrom = function(e) {
	e.loaded && e.buffer && (
		this.buffer = e.buffer,
		this.loaded = true,
		b5.app.debug && console.log("Resource loaded "+this.name)
	);
},
//Reverb effect
b5.Sound.reverbGenerator = function(sample, length) {
	var p = 1-(sample/length),
	r = Math.cos(Math.random()*Math.PI)*Math.sin(Math.random()-sample*-Math.PI);
	if(r > 0.5) r = 1 - r;
	else if(r < -0.5) r = 1 + r;
	return r * b5.Ease.easingFuncs[b5.Ease.cubicout](p);
},
b5.Sound.reverbInvert = function(sample, length) {
	var p = sample/length;
	return ((Math.random()*2)-1) * p * p * p * p;
},
b5.Sound.generateImpulseResponse = function(noiseFunc, duration) {
	var s = this.context.sampleRate,
	r = this.context.createBuffer(2, s*duration, s);
	//Write
	for (var i = 0, d = r.getChannelData(0), e = r.getChannelData(1); i < e.length; i++) d[i] = e[i] = noiseFunc(i, d.length);
	return r;
},
b5.Sound.prototype.play = function(n) {
	var e = this.internal,
	t = this.player.count,
	o = this.reuse ? -1: 1,
	a = this.player.sources;
	this.loaded && (t < o || o == -1) && b5.app.use_web_audio && (
		e._createSource(this),
		e._createNodes(this),
		e._connect(this),
		this.analyser && (
			this.setupAnalyser(),
			this.attachNode(this.analyser)
		),
		this.player.data[t] && (
			!this.stream ? (!this.player.data[t].playing && a[t] && a[t].start(0, n || this.start_pos)): (a[t].mediaElement.play(), a[t].mediaElement.currentTime = n || this.start_pos),
			this.player.data[t].playing=!0,
			this.player.count++,
			n && (this.start_pos = n)
		));
	return this;
},
b5.Sound.prototype.stop = function(e) {
	var t = this.player.count-1,
	o = this.player.sources;
	null != e && -1 !== t && o[e].onended(!0);
	if (!e) for (var i = 0; i < o.length; i++)o[i] && o[i].onended && o[i].onended(!0);
},
b5.Sound.prototype.pause = function(e) {
	var t = this.player.count-1,
	o = this.player,
	a = o.sources;
	null != e && -1 !== t && (
		o.data[e].bufferenabled ? (a[e].playbackRate.value = 0, o.data[e].playbackRateMult = 0): a[e].mediaElement.pause(), o.data[e].playing && (o.data[e].wasplaying=!0), o.data[e].playing=!1);
	if (!e && -1 !== t) for (var i = 0; i < a.length; i++) if (a[i] && o.data[i]) {
		o.data[i].playing && (o.data[i].wasplaying = true),
		o.data[i].bufferenabled ? (a[i].playbackRate.value = 0,
			o.data[i].playbackRateMult = 0): a[i].mediaElement.pause(),
		o.data[i].playing=!1
	}
},
b5.Sound.prototype.resume = function(e) {
	var t = this.player.count-1,
	o = this.player,
	a = o.sources;
	null != e && -1 !== t && (
		o.data[e].bufferenabled ? (a[e].playbackRate.value = o.data[e].playbackRate, o.data[e].playbackRateMult = 1): a[e].mediaElement.play(), o.data[e].wasplaying=!1, o.data[e].playing=!0);
	if (!e && -1 !== t) for (var i = 0; i < a.length; i++)	if (a[i] && o.data[i]) {
		o.data[i].bufferenabled ? (a[i].playbackRate.value = o.data[i].playbackRate,
			o.data[i].playbackRateMult = 1): a[i].mediaElement.play(),
		o.data[i].playing=!0
	}
},
b5.Sound.prototype.setLooping = function(n, e) {
	var t = this.player.count-1,
	o = this.player,
	a = o.sources;
	null != e && -1 !== t && (
		o.data[e].bufferenabled ? a[e].loop = n: a[e].mediaElement.loop = n);
	if (!e) for (var i = 0; i < a.length; i++)o.data[i].bufferenabled ?
	a[i].loop = n: a[i].mediaElement.loop = n;
},
b5.Sound.prototype.setGain = function(n, e) {
	var t = this.player.count-1,
	o = this.player,
	a = o.nodes;
	null != e && -1 !== t && (a[e][0].gain.value = n);
	if (!e && -1 !== t) for (var i = 0; i < a.length; i++) if (a[i]) {
		a[i][0].gain.value = n
	}
	this.gain = n;
},
b5.Sound.prototype.setStereoPan = function(n, e) {
	var t = this.player.count-1,
	o = this.player,
	a = o.nodes;
	null != e && -1 !== t && (a[e][1].pan.value = n);
	if (!e && -1 !== t) for (var i = 0; i < a.length; i++) {
		a[i][1].pan.value = n
	}
	this.stereo_pan = n;
},
b5.Sound.prototype.setPlaybackSpeed = function(n, r, e) {
	var t = this.player.count-1,
	o = this.player,
	a = o.sources;
	r = r ? !0: !1,
	null != e && -1 !== t && (
		o.data[e].bufferenabled ? a[e].playbackRate.value = n: (a[e].mediaElement.preservesPitch = r, a[e].mediaElement.playbackRate = n), o.data[e].playbackRate = n);
	if (!e && -1 !== t) for (var i = 0; i < a.length; i++) {
		o.data[i].bufferenabled ? (a[i].playbackRate.value = n,
			o.data[i].playbackRate = n): (a[i].mediaElement.playbackRate = n, a[i].mediaElement.preservesPitch = r)
	}
	this.playback_speed = n,
	this.keep_pitch = r;
},
b5.Sound.prototype.setDetune = function(n, e) {
	var t = this.player.count-1,
	o = this.player,
	a = o.sources;
	null != e && -1 !== t && o.data[e].bufferenabled && (a[e].detune.value = n);
	if (!e && -1 !== t) for (var i = 0; i < a.length; i++) {
		o.data[i].bufferenabled && (a[i].detune.value = n);
	}
	this.detune = n;
},
b5.Sound.prototype.seekTo = function(n, e) {
	var t = this.player.count-1,
	o = this.player,
	a = o.sources;
	null != e && -1 !== t && (o.data[e].bufferenabled ? (this.stop(e), this.play(n)): a[e].mediaElement.currentTime = n);
	if (!e && -1 !== t) for (var i = 0; i < a.length; i++) {
		o.data[i].bufferenabled ? (this.stop(i), this.play(n)): a[i].mediaElement.currentTime = n;
	}
},
b5.Sound.prototype.Tween = function(param, value, time, easing) {
	var e = ['linearRampToValueAtTime',
		'exponentialRampToValueAtTime','setValueAtTime'],
	f = [],
	n,
	o = this.player;
	easing === void 0 && (easing = 0);
	switch (param) {
		case 'playbackRate':
			for (var i = 0; i < o.sources.length; i++) f.push(o.sources[i]);
			break;
		case 'gain:main':
			for (var i = 0; i < o.nodes.length; i++) f.push(o.nodes[i][0]);
			break;
		case 'gain:output':
			for (var i = 0; i < o.nodes.length; i++) f.push(o.nodes[i][4]);
			break;
		case 'gain:reverb':
			for (var i = 0; i < o.nodes.length; i++) o.nodes[i].REVERB_NODE && f.push(o.nodes[i].REVERB_NODE.gainNode);
			break;
		case 'pan:stereo':
			for (var i = 0; i < o.nodes.length; i++) f.push(o.nodes[i][1]);
			break;
		case 'frequency:eq':
		case 'detune:eq':
		case 'Q:eq':
		case 'gain:eq':
			for (var i = 0; i < o.nodes.length; i++) f.push(o.nodes[i][2]);
			break;
		case 'threshold:limiter':
		case 'knee:limiter':
		case 'ratio:limiter':
		case 'attack:limiter':
		case 'release:limiter':
	  	for (var i = 0; i < o.nodes.length; i++) f.push(o.nodes[i][3]);
	}

	var p = param.indexOf(':');
	param = param.substr(0, p === -1 ? param.length: p);
	for (var i = 0; i < f.length; i++) {
		f[i][param].setValueAtTime(f[i][param].value, this.context.currentTime); //Register
		f[i][param][e[easing]](value, this.context.currentTime + time);
	}
}
b5.Sound.prototype.isPlaying = function(e) {
	var t = this.player.data;
	if (e)return t[e].playing;
	else for (var i = 0; i < t.length; i++)if (t[i].playing)return !0;
	return !1;
};
b5.Sound.prototype.wasPlaying = function(e) {
	var t = this.player.data;
	if (e)return t[e].wasplaying;
	else for (var i = 0; i < t.length; i++)if (t[i].wasplaying)return !0;
	return !1;
};

//Effect setters (if enabled)
b5.Sound.prototype.setEqualizer = function(e, t, o, a, c, l) {
	var n = this.player.count-1,
	r = this.player,
	i = r.nodes,
	m = null,
	p = this.eq;
	isNaN(a) && (a = 0);
	isNaN(c) && (c = 0);
	null != l && -1 !== n && (m = i[i][i[l].findIndex(eq=>eq == "[object BiquadFilterNode]")],
		m.type = e,
		m.frequency.value = t,
		m.gain.value = o,
		m.Q.value = a,
		m.detune.value = c
	);
	if (!l && -1 !== n) for (var q = 0; q < i.length; q++) {
		m = i[q][i[q].findIndex(eq=>eq == "[object BiquadFilterNode]")];
		m && (m.type = e,
			m.frequency.value = t,
			m.gain.value = o,
			m.Q.value = a,
			m.detune.value = c);
	};
	//Set default
	p.type = e,
	p.freq = t,
	p.gain = o,
	p.Q = a,
	p.detune = c;
};
b5.Sound.prototype.setOutputGain = function(e, l) {
	var n = this.player.count-1,
	r = this.player,
	i = r.nodes,
	m = null,
	p = this.eq;
	null != l && -1 !== n && (m = i[l][4],
		m.gain.value = e
	);
	if (!l && -1 !== n) for (var q = 0; q < i.length; q++) if(i[q] && i[q][4]) {
		m = i[q][4];
		m.gain.value = e;
	};
	//Set default
	this.output_gain = e;
};
b5.Sound.prototype.setReverbGain = function(e, l) {
	var n = this.player.count-1,
	r = this.player,
	i = r.nodes,
	m = null,
	p = this.eq;
	null != l && -1 !== n && i[l].REVERB_NODE && (m = i[l].REVERB_NODE.gainNode,
		m.gain.value = e * 4.5
	);
	if (!l && -1 !== n) for (var q = 0; q < i.length; q++) if(i[q] && i[q].REVERB_NODE) {
		m = i[q].REVERB_NODE.gainNode;
		m.gain.value = e * 4.5;
	};
};
//You can get the response frequencies the equalizer is making,
//Make sure to use it gently, putting it in a loop can cause audio crackling!
b5.Sound.prototype.getEQFreqResponse = function(e, t, o) {
	var a = this.player.nodes;
	if (this.equalizer && a.length > 0) {
		var n = a[a.length-1],
		r = n[n.findIndex(eq=>eq == "[object BiquadFilterNode]")],
		i = Float32Array,
		s = new i(e),
		m = new i(e);
		!e && (e = 8),
		!t && (t = 20),
		!o && (o = 2000);
		//Set frequencies for each band
		for (var b = 0; b < e; b++) s[b] = (b*(o/e))+t;
		//Get band frequencies and set it to output frequencies array.
		void r.getFrequencyResponse(s, m, new i(e));
		//Send output
		return m;
	}
	return new Float32Array(e);
};
//You can also get the dB reduction of the limiter, if enabled and playing
b5.Sound.prototype.getCompressorReduction = function() {
	var e = this.player.nodes;
	if (e.length > 0 && this.limiter) {
		var t = e[e.length-1],
		o = t[t.findIndex(eq=>eq == "[object BiquadFilterNode]")];
		return o.reduction;
	}
	return 0;
}
b5.Sound.prototype.setCompressor = function(e, t, o, a, v, l) {
	var n = this.player.count-1,
	r = this.player,
	i = r.nodes,
	m = null,
	p = this.compressor;
	o += 1;
	null != l && -1 !== n && (m = i[i][i[l].findIndex(eq=>eq == "[object DynamicsCompressorNode]")],
		m.threshold.value = e,
		m.knee.value = t,
		m.ratio.value = o,
		m.attack.value = a,
		m.release.value = v
	);
	if (!l && -1 !== n) for (var q = 0; q < i.length; q++) {
		m = i[q][i[q].findIndex(eq=>eq == "[object DynamicsCompressorNode]")];
		m.threshold.value = e,
		m.knee.value = t,
		m.ratio.value = o,
		m.attack.value = a,
		m.release.value = v
	};
	//Set default
	p.threshold = e,
	p.knee = t,
	p.ratio = o,
	p.attack = a,
	p.release = v
};
b5.Sound.prototype.setupAnalyser = function(e, t, o, a, n) {
	var r = this.analyser;
	e && (r.fftSize = e),
	t != null && (r.minDecibels = t),
	o != null && (r.maxDecibels = o),
	a != null && (r.smoothingTimeConstant = a),
	n && (r.type = n),
	!r.buffer && (r.buffer = new Uint8Array(r.frequencyBinCount)),
	!r.buffer2 && (r.buffer2 = new Float32Array(r.frequencyBinCount))
};
b5.Sound.prototype.getAnalyserData = function(e) {
	var t = this.analyser,
	o = t.buffer,
	a = t.buffer2;
	if (a && o) {
		switch (t.type) {
			case "frequencies":
				e ? t.getByteFrequencyData(o):
				t.getFloatFrequencyData(a);
				break;
			case "waveform":
				e ? t.getByteTimeDomainData(o):
				t.getFloatTimeDomainData(a);
				break;
		}
		return e?o: a;
	} else return [];
};

//Experimental: Custom nodes
//You can create custom nodes in your script and attach them to the players
//Take note: The node will be added to the last node connected to the player,
//so every effect added previously will be fed into the node.
//You can add it to the destination so it can be played on top of the audio,
//for certain effects, or creating an AnalyserNode to use it in an audio spectrum.
//This will affect the last player created, and won't be removed automatically.
//For more information about WebAudio API visit https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API
b5.Sound.prototype.attachNode = function(e, t) {
	var o = this.player.nodes,
	a = o[o.length-1],
	b = a[a.length-1];
	b5.app.debug && console.log("Connecting "+b+" to "+e),
	b.connect(e),
	t && (b5.app.debug && console.log("Connecting "+t+" to destination"),
		t.connect(this.context.destination));
};